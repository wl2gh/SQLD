● 모델링
- 현실 세계의 비즈니스 프로세스와 데이터 요구 사항을 추상적이고 구조화된 형태로 표현하는 과정

● 모델링 특징
1.단순화
2.추상화
3.명확화

● 데이터 모델링 3가지 관점
1.데이터관점
2.프로세스관점
3.데이터와프로세스 관점

● 데이터 모델링 유의점
1.중복
2.비유연성
3.비일관성

● 데이터 모델링의 3단계
1.개념적 모델링
- 업무 중심적, 핵심 엔티티를 추출하는 단계

2.논리적 모델링
- 개념적 모델링을 토대로 세부속성,식별자,관계 등을 표현하는 단계
- 데이터 정규화 수행, 재사용 가능

3.물리적 모델링
- 논리 모델링이 끝나면 이를 물리적으로 직접 생성하는 과정

아래로 갈수록 구체화되고 위로 갈수록 추상화

● 스키마 3단계 
1.외부 스키마 - 사용자가 보는 관점
2.개념 스키마 - 데이터베이스의 전체 논리적 구조(논리 모델링에서 만들어짐)
3.내부 스키마 - 물리적으로 어떻게 저장되어지는지를 논의(물리 모델링)

-독립성
-논리적 독립성
-물리적 독립성

● ERD 작성 절차
1. 엔티티를 도출한 후 그린다.
2. 엔티티 배치
3. 엔티티 간의 관계를 설정
4. 관계명을 서술
5. 관계의 참여도 기술
6. 관계의 필수 여부 확인

● 엔티티 특징
- 2개 이상의 인스턴스
- 각 엔티티는 2개 이상의 속성
- 다른 엔티티와 최소 1개 이상의 관계 성립
- 한개의 속성은 한개의 속성만 갖는다

● 엔티티 분류
1. 유형엔티티(실체)
2. 개념엔티티(물리적 형태X)
3. 사건엔티티(업무 수행에 따라 발생)

2) 발생 시점
1. 기본엔티티
2. 중심엔티티
3. 행위엔티티

● 속성의 분류
1. 기본속성
2. 설계속성
3. 파생속성

● 주식별자 특징
1. 유일성
2. 최소성
3. 불변성
4. 존재성

● 정규화
- 최소한의 데이터만을 하나의 엔티티에 넣는식으로 데이터를 분해하는 과정
- 중복을 제거, 독립성 확보
- 이상현상을 줄이기 위함

● 정규화 단계
1단계 = 분리
2단계 = 완전 함수 종속을 위배하는 키를 PK으로부터 분리
3단계 = 이행적 종ㅅ혹을 없애도록 테이블을 분리

● 관계형 데이터베이스 특징
- 데이터의 분류, 정렬, 탐색 속도 빠름
- 신뢰성이 높고, 데이터 무결성 보장
- 기존의 작성된 스키마 수정 어려움
- 데이터베이스의 부하를 분석하기 어려움

● 데이터 무결성
- 데이터의 정확성과 일관성을 유지하고, 데이터에 결손과 부정합이 없음을 보장하는 것
● 데이터 무결성 종류
1. 개체 무결성
2. 참조 무결성
3. 도메인 무결성
4. NULL 무결성
5. 고유 무결성
6. 키 무결성

● ERD
- 테이블 간 서로의 상관 관계를 그림으로 표현한 것(엔티티, 관계, 속성)

● SELECT문 구조
- FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY

● 컬럼 ALIAS(별칭)
- 컬럼명 대신 출력할 임시 이름 지정

● 함수
- input value가 있을 경우 그에 맞는 output value를 출력해주는 개체

● 함수 기능
- 기본적인 쿼리문을 더욱 강력하게 해줌
- 데이터의 계산을 수행
- 개별 데이터의 항목을 수정
- 표시할 날짜 및 숫자 형식을 지정
- 열 데이터의 유형을 변환

● 함수의 종류
- input과 output 관계가 1:1인 단일행 함수
- 여러 건의 데이터를 동시에 입력받아 하나의 요약값을 리턴하는 복수행 함수

● 숫자형 함수
- ABS = 절대값 반환
- ROUND(숫자,자리수) = 소수점 특정 자리에서 반올림
- TRUNC(숫자,자리수) = 소수점 특정 자리에서 버림
- SIGN(숫자) = 숫자가 양수면 1 음수면 -1 0이면 0반환
- FLOOR(숫자) = 작거나 같은 최대 정수 리턴
- CEIL(숫자) = 크거나 같은 최소 정수 리턴
- MOD(숫자1, 숫자2) = 숫자1을 숫자2로 나누어 나머지 반환
- POWER(m,n) = m의 n거듭제곱
- SQRT(숫자) = 루트값 리턴
 
● 날짜형 함수
- SYSDATE = 현재 날짜와 시간 리턴
- CURRENT_DATE = 현재 날짜 리턴
- CURRENT_TIMESTAMP = 현재 타임스탬프 리턴
- ADD_MONTHS(날짜,n) = 날짜에서 n개월 후 날짜 리턴
- MONTH_BETWEEN(날짜1,날짜2) = 날짜1과 날짜2의 개월 수 리턴
- LAST_DAY(날짜) = 주어진 월의 마지막 날짜 리턴
- NEXT_DAY(날짜,n) = 주어진 날짜 이후 저장된 요일의 첫 번째 날짜 리턴
- ROUND(날짜,자리수) = 날짜 반올림
- TRUNC(날짜,자리수) = 날짜 버림

● 변환함수 종류
- TO_NUMBER(문자) = 숫자 타입으로 변경하여 리턴
- TO_CHAR(대상,포맷) = 1)날짜의 포맷 변경 2)숫자의 포맷 변경
- TO_DATE(문자,포맷) = 주어진 문자를 포맷 형식에 맞게 읽어 날짜로 변경
- FORMAT(날짜,포맷) = 날자의 포맷 변경
- CAST(대상 AS 데이터타입) = 대상을 주어진 데이터타입으로 변환

● 그룹함수
- COUNT,SUM,AVG,MIN,MAX,VARIANCE,STDDEV

● 일반함수
- DECODE(대상,값1,리턴1,값2,리턴2,~,그외리턴) = 대상이 값1이면 리턴1, 값2와 같으면 리턴2, 그외에는 그외리턴값 리턴
- NVL(대상,치환값) = 대상이 널이면 치환값으로 치환하여 리턴
- NVL2(대상,치환값1,치환값2) = 대상이 널이면 치환값2로 치환, 널이 아니면 치환값1로 치환하여 리턴
- COALESCE(대상1,대상2,~,그외리턴) = 대상들 중 널이 아닌값 출력(가장 첫번째부터) 대상1, ~, 모두가 널이면 그외리턴값이 리턴됨
- ISNULL(대상,치환값) = 대상이 널이면 치환값이 리턴
- NULLIF(대상1,대상2) = 두 값이 널이면 널리턴, 다르면 대상1 리턴
- CASE문 = 조건별 치환 및 연상 수행

● WHERE 절
- 연산자(=,!=,<>,>,>=,<,<=,BETWEEN A AND B,IN(A,B,C),LIKE,IS NULL/IS NOT NULL,A AND B,A OR B,NOT A)

● LIKE 연산자
- ENAME LIKE 'S%' = 이름이 S로 시작하는
- ENAME LIKE '%S%' = 이름에 S를 포함하는
- ENAME LIKE '%S' = 이름이 S로 끝나는
- ENAME LIKE '_S%' = 이름의 두 번째 글자가 S인
- ENAME LIKE '_S_' = 이름이 가운데 글자가 S이며 이름의 길이가 5글자인

● JOIN문
1.조건의 형태에 따라
1)EQUI JOIN(등가 JOIN) : JOIN 조건이 동등 조건인 경우
2)NON EQUI JOIN : JOIN 조건이 동등 조건이 아닌 경우

2.조인 결과에 따라
1)INNER JOIN : JOIN 조건에 성립하는 데이터만 출력하는 경우
2)OUTER JOIN : JOIN 조건에 성립하지 않는 데이터도 출력하는 경우
3)NATURAL JOIN : 조인조건 생략 시 두 테이블에 같은 이름으로 자연 연결되는 조인
4)CROSS JOIN : 조인조건 생략 시 두 테이블의 발생 가능한 모든 행을 출력하는 조인
5)SELF JOIN : 하나의 테이블을 두 번 이상 참조하여 연결하는 조인

● 서브쿼리
- 하나의 SQL문 안에 포함된 또 다른 SQL 문을 의미
- 비연관,연관 서브쿼리
- SELECT 절에 사용하는 서브쿼리(스칼라 서브쿼리)
- FROM 절에 사용하는 서브쿼리(인라인뷰)
- WHERE절 서브쿼리
★ 스칼라 -> 인라인 -> 서브쿼리 ★

● 다중컬럼 서브쿼리
- 서브쿼리 결과가 여러 컬럼을 리턴하는 형식

● 상호연관 서브쿼리
- 메인쿼리와 서브쿼리 간의 비교를 수행하는 형태

● 인라인뷰
- 쿼리 안의 뷰의 형태로, 테이블처럼 조회할 데이터를 정의하기 위해 사용

● 스칼라 서브쿼리
- SELECT 절에 사용하는 쿼리로, 마치 하나의 컬럼처럼 표현하기 위해 사용

● 집합 연산자
1. 중복된 데이터 한번만 출력 = UNION
2. 중복된 데이터 전체 출력 = UNION ALL
3. 두 집합 사이에 교집합 = INTERSECT
4. 두 집합 사이에 차집합 = MINUS

● GROUPING SETS(A,B,...)
- A별,B별 그룹 연산 출력
● ROLL UP(A,B)
- A별,(A,B)별,전체 그룹 연산 결과 출력(전체 결과 출력이 맨아래 출력)
● CUBE(A,B)
- A별,B별,(A,B)별,전체 그룹 연산 결과 출력(전체 결과 출력이 맨위에 출력)

● WINDOW FUNCTION
- 서로 다른 행의 비교나 연산을 위해 만든 함수
- PARTITION BY 절 -> ORDER BY 절 -> ROWS|RANGE BETWEEN A AND B순

ROWS|RANGE BETWEEN A AND B
1.ROWS|RANGE = 범위
2.A = 시작점
- CURRENT ROW : 현재 행부터
- UNBOUNDED PRECEDING : 처음부터
- N PRECEDING : N 이전부터
3.B = 마지막 지점
- CURRENT ROW : 현재 범위까지
- UNBOUNDED FOLLOWING : 마지막까지
- N FOLLOWING : N 이후까지

● 순위 함수
- RANK OVER, DENSE_RANK, ROW_NUMBER
RANK는 1,2,2,4순
DENSE_RANK는 1,2,2,3순
ROW_NUMBER는 1,2,3,4순  

● 비율 함수
- RATIO_TO_REPORT, CUME_DIST, PERCENT_RANK

● TOP N QUERY
1.ROWNUM
2.RANK
3.FETCH
4.TOP N

● PIVOT과 UNPIVOT
- LONG과 WIDE 데이터가 있음 LONG은 테이블 설계방식 WIDE는 요약한 데이터
PIVOT = LONG -> WIDE
UNPIVOT = WIDE -> LONG

● DML
- INSERT,UPDATE,DELETE,MERGE

● TCL
- COMMIT,ROLLBACK
● 트랜잭션의 특성
- 원자성
- 고립성
- 지속성
- 일관성 

● DDL 
- CRATE,ATER,DROP,TRUNCATE

● DCL
- GRANT,REVOKE
- WITH GRANT OPTION, WITH ADMIN OPTION
WITH GRANT OPTION = 중간관리자가 있음, 중간관리자만 회수가능, 중간관리자 권한 회수시 3자도 회수
WITH ADMIN OPTION = WITH GRANT OPTION 반대

1차 정규화 = 중복성 제거
2차 정규화 = 부분 종속성 제거
3차 정규화  = 이행 종속성 제거
ntile = 그룹으로 나누는거
Lead(대상,순서,디폴트값)
Truncate table은 모든 행을 삭제
프로시저는 execute로 실행 commit,rollback가능 트리거는 자동실행 commit,rollback 불가
인덱스는 데이터를 더빨리 찾기위한 목차같은 구조 
다중행서브쿼리는 연산 in any같은걸 써야된다
natural join은 식별자를 가질수없다
rollup은 a,(a,b),전체계산
cube는 a,b,(a,b),전체계산
grouping sets은 맘대로 정하는거
분산데이터는 신뢰성과 가용성이 높다, 병렬처리 가능 그러나 관리와 보안 통제가 어렵고 무결성 관리가 어렵다
alter는 테이블을 변경하는 명령어 modify는 그중 하나로 컬럼의 타입이나 제약 조건을 변경
count(1) = count(*) null값도 센다, count는 null을 안세서 0으로 출력
Nested Loop join = 한 테이블의 각 행에 대해 다른 테이블 전체를 반복 탐색하면서 조건이 맞는 행을 찾는 방식(적은 데이터 조인할때 유리)
Hash join = 온라인 트랙잭션 처리에 유용
unique index scan을 사용하려면 칼럼값을 모두 사용해야함
페어링 = 엔티티 안의 인스턴스가 개별적으로 관계를 가지는 것
트랜잭션 = 두 엔티티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성
ORDER BY절에는 GROUP BY에 사용하지 않은 컬럼을 명시할 수 없다
offset = 건너뜀 ex) offset 2 = 2번 건너뛰고 그행을 읽겠다.
GROUP BY 절에 명시되지 않은 컬럼은 ORDER BY 절에 사용할 수 없다
ASC시 null은 제일 마지막에 DESC시 null은 제일 첫번째로 출력
PIVOT 시 FOR 앞에는 반드시 집계함수(SUM, AVG 등)의 형태여야 한다.
